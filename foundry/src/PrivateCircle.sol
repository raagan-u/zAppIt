// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IMoproVerifier {
    // The verifier interface generated by Noir/Mopro
    function verifyProof(
        bytes calldata proof,
        uint256[] calldata publicInputs
    ) external view returns (bool);
}

contract PrivateCircle {
    IMoproVerifier public verifier;

    // Track used nullifier commitments to prevent double-post / double-vote
    mapping(uint256 => bool) public nullifierUsed;

    // Track posts and votes
    mapping(bytes32 => uint256) public postVotes; // ipfsHash => vote count
    mapping(bytes32 => uint256) public postDownvotes; // ipfsHash => downvote count
    
    // Events
    event ContentPosted(bytes32 indexed ipfsHash, uint256 nullifierCommitment, address indexed submitter);
    event VoteCast(bytes32 indexed ipfsHash, uint256 voteOption, uint256 nullifierCommitment, address indexed voter);

    constructor(address _verifier) {
        verifier = IMoproVerifier(_verifier);
    }

    // ---------------------------
    // Post encrypted content
    // ---------------------------
    function postContent(
        bytes calldata proof,
        uint256 nullifierCommitment,
        bytes32 ipfsHash
    ) external {
        require(!nullifierUsed[nullifierCommitment], "Already used");

        // Prepare public inputs as expected by Noir/Mopro circuit
        uint256[] memory publicInputs = new uint256[](2);
        publicInputs[0] = nullifierCommitment;
        publicInputs[1] = uint256(ipfsHash);

        require(verifier.verifyProof(proof, publicInputs), "Invalid proof");

        // Mark nullifier as used
        nullifierUsed[nullifierCommitment] = true;

        emit ContentPosted(ipfsHash, nullifierCommitment, msg.sender);
    }

    // ---------------------------
    // Cast a vote
    // ---------------------------
    function castVote(
        bytes calldata proof,
        uint256 nullifierCommitment,
        bytes32 ipfsHash,
        uint256 voteOption
    ) external {
        require(!nullifierUsed[nullifierCommitment], "Already used");
        require(voteOption == 0 || voteOption == 1, "Invalid vote");

        uint256[] memory publicInputs = new uint256[](2);
        publicInputs[0] = nullifierCommitment;
        publicInputs[1] = voteOption;

        require(verifier.verifyProof(proof, publicInputs), "Invalid proof");

        nullifierUsed[nullifierCommitment] = true;

        // Update vote counts
        if (voteOption == 1) {
            postVotes[ipfsHash]++;
        } else {
            postDownvotes[ipfsHash]++;
        }

        emit VoteCast(ipfsHash, voteOption, nullifierCommitment, msg.sender);
    }

    // ---------------------------
    // View functions
    // ---------------------------
    function getPostVotes(bytes32 ipfsHash) external view returns (uint256 upvotes, uint256 downvotes) {
        return (postVotes[ipfsHash], postDownvotes[ipfsHash]);
    }

    function isNullifierUsed(uint256 nullifierCommitment) external view returns (bool) {
        return nullifierUsed[nullifierCommitment];
    }
}